# SvelteKit + Supabase + PostGIS + Leaflet Project

> Community fire safety and property management platform for NSW communities
> Multi-tenant SaaS serving BCYCA, Mondrook, Tinonee communities

## Stack & Key Decisions

**Frontend:** SvelteKit 2.x, Svelte 5, TypeScript, Tailwind CSS v4
**Backend:** Supabase (PostgreSQL + PostGIS), Row Level Security
**Mapping:** Leaflet, ESRI services, NSW Spatial Services, Geoscape
**Hosting:** Vercel (Sydney region)

**Why This Stack:**
- **SvelteKit**: Full-stack SSR framework with file-based routing and excellent TypeScript support
- **Supabase**: Managed PostgreSQL with PostGIS spatial support and built-in RLS for multi-tenant security
- **Leaflet**: Mature, performant mapping library with extensive plugin ecosystem and flexible styling
- **PostGIS**: Industry-standard spatial database for complex geographic queries at scale
- **Vercel**: Edge deployment in Sydney region for low-latency Australian users

---

## Project Domain

### Fire Safety Management
Platform helps NSW rural communities manage:
- Property fire safety assessments and planning
- Community asset mapping (water sources, shelters, hazards)
- Evacuation planning and coordination
- Property risk profiling and monitoring

### Multi-Tenant Architecture
Three community tenants with shared infrastructure:
- **BCYCA** (Bushfire Community Yengo Area)
- **Tinonee** community
- **Mondrook** community
- Plus external community members

Each community has separate profiles, permissions, and data access controlled via RLS.

---

## Unique Architectural Patterns

### 1. Template-Based Feature System

Spatial features are defined by templates stored in the database, not hardcoded:

```typescript
// Database: spatial_feature_templates table
{
  template_id: uuid,
  template_name: string,
  geometry_type: 'Point' | 'LineString' | 'Polygon',
  attributes_schema: jsonb,  // Dynamic attribute fields
  symbology_config: jsonb    // Rendering configuration
}
```

**Benefits:**
- Non-developers can create new feature types via admin interface
- Symbology, validation, and forms are template-driven
- Easy to add new asset types without code changes

**Implementation Pattern:**
```svelte
// Map component receives features grouped by template
<Leafletmap featuresByTemplate={{
  'water-source': { type: 'FeatureCollection', features: [...] },
  'refuge-area': { type: 'FeatureCollection', features: [...] }
}} />

// When user selects layer, active template is set
function selectLayer(layerName: string) {
  const layer = layers[layerName];
  if (layer?.template_id) {
    const template = featureTemplates[layer.template_id];
    setActiveTemplate(template);  // Drives editing UI
  }
}
```

### 2. Property-Centric Authorization Model

Authorization centers on property ownership, not just user roles:

**JWT Custom Claims:**
```typescript
{
  user_role: 'user' | 'kyng_coordinator' | 'admin',
  property_ids: string[],           // Properties user can access
  community_slugs: string[],         // Communities user belongs to
  permissions: string[]              // Fine-grained permissions
}
```

**RLS Implementation:**
```sql
-- Users can only see properties they own
CREATE POLICY "property_access" ON property_profile
  USING (id = ANY((SELECT auth.jwt()->>'property_ids')::uuid[]))
```

**Route Guards (UX Layer):**
```typescript
// hooks.server.ts extracts propertyId from URLs like:
// /personal-profile/my-property/[propertyid]/my-map
const propertyMatch = path.match(/\/my-property\/([^\/]+)/);
if (propertyMatch && !event.locals.propertyIds.includes(propertyMatch[1])) {
  throw redirect(303, '/personal-profile/my-property');
}
```

This ensures URLs with property IDs are validated (UX), while RLS provides true security.

### 3. Multi-Community Profile System

Users have:
- **One user profile** (personal information, postal address)
- **Multiple community profiles** (BCYCA, Tinonee, Mondrook, External)
- **Multiple property profiles** (linked to communities)

**Data Loading Pattern:**
```typescript
// +layout.server.ts
const { data: userProfile } = await supabase.rpc('get_profile_for_user', {
  id_input: user.id
});

// RPC returns joined data:
// - user_profile (1:1)
// - community_bcyca_profile (1:1 or null)
// - community_tinonee_profile (1:1 or null)
// - community_mondrook_profile (1:1 or null)
// - property_profile[] (1:many)
```

### 4. Map Context Pattern

Leaflet instances are shared via Svelte context to avoid prop drilling:

```svelte
// Leafletmap.svelte - Parent map component
setContext('leafletContext', {
  getLeaflet: () => leaflet,
  getLeafletMap: () => leafletMap,
  getEsriLeaflet: () => esriLeaflet,
  getLeafletDraw: () => leafletDraw,
  getLayersControl: () => layersControlStore
});

// Child layer components
const { getLeafletMap, getLeaflet } = getContext('leafletContext');
const map = getLeafletMap();
const L = getLeaflet();
```

**Dynamic Import for SSR Safety:**
```svelte
let leaflet = $state<typeof L>();
let leafletMap = $state<L.Map>();

onMount(async () => {
  const leafletModule = await import('leaflet');
  leaflet = leafletModule;
  
  if (mapDiv && leaflet) {
    leafletMap = leaflet.map(mapDiv, { /* options */ });
  }
});
```

---

## NSW-Specific Service Integrations

### 1. GURAS Address Validation

**NSW Government Urban and Regional Address Service:**
```typescript
// API Route: src/routes/api/validate-address/+server.ts
const response = await fetch(
  `https://portal.spatial.nsw.gov.au/server/rest/services/NSW_Geocoded_Addressing_Theme/FeatureServer/1/query`,
  {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${GURAS_API_KEY}` }
  }
);
```

**Use Cases:**
- Validate property addresses during onboarding
- Geocode addresses to coordinates for mapping
- Standardize address formats across communities

### 2. Geoscape Vector Tiles

**Geoscape Australia Cadastre API:**
```typescript
// Fetch cadastral boundaries as vector tiles
const tileUrl = `https://api.geoscape.com.au/v2/tiles/cadastre/{z}/{x}/{y}.pbf?key=${GEOSCAPE_API_KEY}`;

// Decode Protobuf (PBF) tiles client-side
import Protobuf from 'pbf';
import { VectorTile } from '@mapbox/vector-tile';

const vt = new VectorTile(new Protobuf(arrayBuffer));
```

**Benefits:**
- Accurate property boundaries for NSW properties
- Lightweight vector format vs raster tiles
- Enables client-side styling and interaction

### 3. NSW Spatial Services WMS/WFS

ESRI FeatureServer integration for NSW government spatial data:
```typescript
import * as EsriLeaflet from 'esri-leaflet';

const featureLayer = EsriLeaflet.featureLayer({
  url: 'https://mapprod3.environment.nsw.gov.au/arcgis/rest/services/...'
});
```

---

## PostGIS Query Patterns

### Spatial Relationships

**Find properties within bushfire buffer zones:**
```sql
SELECT p.id, p.property_address_street
FROM property_profile p
WHERE ST_Intersects(
  p.geometry,
  ST_Buffer(
    (SELECT geometry FROM bushfire_hazard WHERE severity = 'extreme'),
    100  -- 100m buffer
  )
);
```

**Calculate distance to nearest water source:**
```sql
SELECT 
  p.id,
  MIN(ST_Distance(p.geometry, w.geometry)) as distance_meters
FROM property_profile p
CROSS JOIN spatial_feature w
WHERE w.template_id = 'water-source-template-uuid'
GROUP BY p.id;
```

### GeoJSON Conversion

**RPC Function Pattern:**
```sql
CREATE OR REPLACE FUNCTION get_property_geometry(id_input uuid)
RETURNS json AS $$
  SELECT ST_AsGeoJSON(geometry)::json
  FROM property_profile
  WHERE id = id_input;
$$ LANGUAGE sql SECURITY DEFINER;
```

**Usage:**
```typescript
const { data: geoJSON } = await supabase.rpc('get_property_geometry', {
  id_input: propertyId
});
```

### Coordinate Systems

**Standard SRID: 7844 (GDA2020)**
```sql
-- Always verify SRID when inserting geometry
INSERT INTO spatial_feature (geometry)
VALUES (ST_GeomFromGeoJSON('{"type":"Point",...}', 7844));

-- Transform if needed
ST_Transform(geometry, 7844)
```

---

## Performance Optimizations

### 1. YouTube Embed Optimization

**Problem:** Default YouTube embeds loaded 2-4MB of resources per video, causing 60+ second page loads.

**Solution:** Custom lazy-loading component with facade:
```svelte
<!-- Lazy load iframe only on user interaction -->
<div on:click={loadVideo}>
  <img src="https://img.youtube.com/vi/{videoId}/maxresdefault.jpg" />
  <PlayButton />
</div>

{#if showIframe}
  <iframe src="https://www.youtube.com/embed/{videoId}" />
{/if}
```

**Result:** Reduced initial page load from 60s to ~5s.

### 2. Map Component Lazy Loading

**Problem:** Leaflet imports on every page caused slow hydration.

**Solution:** Dynamic imports with loading states:
```svelte
{#await import('$components/map/leaflet/Leafletmap.svelte')}
  <MapSkeleton />
{:then { default: Leafletmap }}
  <Leafletmap {...mapProps} />
{/await}
```

### 3. Client-Side Auth Bottleneck

**Problem:** Supabase auth checks blocking client-side rendering.

**Solution:** Server-side session in layout, pass to client:
```typescript
// +layout.server.ts - Run once server-side
const { data: { session } } = await supabase.auth.getSession();
return { session };

// +layout.ts - Hydrate client
export const load: LayoutLoad = async ({ data }) => {
  const supabase = createBrowserClient(...);
  return { supabase, session: data.session };
};
```

---

## Security Architecture

### Three-Layer Security Model

**Layer 1: Database RLS (PRIMARY)**
- All tables have RLS policies
- Enforcement happens at PostgreSQL level
- Cannot be bypassed by application code

**Layer 2: JWT Custom Claims**
- `user_role`, `property_ids`, `community_slugs`, `permissions`
- Generated by database trigger on profile changes
- Used in RLS policies via `auth.jwt()`

**Layer 3: Application Guards (UX ONLY)**
- Server hooks prevent confusing 403 errors
- Route matchers for role-based routing
- Client-side guards for UI state

**Critical Principle:**
> Guards are for UX. RLS is for security. Never trust application-level checks alone.

### Example RLS Policy

```sql
CREATE POLICY "community_data_access" ON community_bcyca_profile
  FOR SELECT USING (
    -- Admin can see all
    (auth.jwt()->>'user_role' = 'admin')
    OR
    -- KYNG coordinators can see their community
    (
      (auth.jwt()->>'user_role' = 'kyng_coordinator')
      AND 'bcyca' = ANY((auth.jwt()->>'community_slugs')::text[])
    )
    OR
    -- Users can see their own profile
    (auth.uid() = user_id)
  );
```

---

## Known Technical Debt

### Svelte 4/5 Hybrid Pattern (TO FIX)

**Current State:** Map components mix Svelte 4 stores with Svelte 5 runes:
```typescript
// Mixed pattern in Leafletmap.svelte:
let leaflet = $state<typeof L>();              // Svelte 5
const leafletStore: Writable<typeof L> = writable(null);  // Svelte 4
```

**Target State:** Migrate fully to Svelte 5 patterns:
```typescript
// Pure Svelte 5:
let leaflet = $state<typeof L>();
let leafletMap = $state<L.Map>();

// Context without stores
setContext('leafletContext', {
  getLeaflet: () => leaflet,
  getLeafletMap: () => leafletMap
});
```

**Migration Priority:** Medium - works but inconsistent, refactor when touching map code.

---

## Common Development Tasks

### Adding a New Spatial Feature Template

1. Insert template in Supabase dashboard:
```sql
INSERT INTO spatial_feature_templates (template_name, geometry_type, attributes_schema, symbology_config)
VALUES (
  'Fire Hydrant',
  'Point',
  '{"fields": [{"name": "pressure", "type": "number"}]}'::jsonb,
  '{"icon": "hydrant", "color": "blue"}'::jsonb
);
```

2. Template automatically appears in map editor UI
3. Symbology renderer uses `symbology_config` for styling
4. No code changes required

### Adding a New Route with Property Access

1. Create route: `src/routes/personal-profile/my-property/[propertyid]/new-page/+page.svelte`
2. Add server load:
```typescript
// +page.server.ts
export const load: PageServerLoad = async ({ params, locals }) => {
  // RLS automatically filters by property_ids in JWT
  const { data } = await locals.supabase
    .from('property_profile')
    .select('*')
    .eq('id', params.propertyid)
    .single();
  
  return { property: data };
};
```

3. Route guard automatically validates `params.propertyid` against JWT claims (UX layer)
4. RLS enforces access control (security layer)

### Debugging Spatial Queries

**View geometry in PostGIS:**
```sql
-- Check SRID
SELECT ST_SRID(geometry) FROM property_profile WHERE id = '...';

-- View GeoJSON
SELECT ST_AsGeoJSON(geometry)::json FROM property_profile;

-- Check if geometry is valid
SELECT ST_IsValid(geometry), ST_IsValidReason(geometry)
FROM property_profile;
```

**Common Issues:**
- SRID mismatch: Always use 7844 (GDA2020)
- Invalid geometry: Run `ST_MakeValid()` on import
- Empty geometries: Check for null coordinates in GeoJSON

---

## Environment Variables

**NSW-Specific Services:**
```bash
GURAS_API_KEY=...              # NSW address validation
GEOSCAPE_API_KEY=...           # Cadastre vector tiles
```

**Standard:**
```bash
PUBLIC_SUPABASE_URL=...
PUBLIC_SUPABASE_ANON_KEY=...
CRON_SECRET=...                # Vercel scheduled jobs
```

---

## File Structure (Key Directories)

```
src/
├── routes/
│   ├── admin/                          # Admin-only (role: admin)
│   ├── kyng-coordinator/               # KYNG coordinator routes
│   ├── personal-profile/
│   │   └── my-property/[propertyid]/   # Property-specific routes
│   └── api/                            # API endpoints
├── components/
│   ├── form/                           # Form inputs and validation
│   ├── map/leaflet/                    # Leaflet map components
│   │   ├── controls/                   # Map controls
│   │   └── layers/                     # Layer components
│   └── page/                           # Navigation, modals, tabs
├── lib/
│   ├── server/
│   │   ├── auth/                       # Route matchers, guards
│   │   ├── services/                   # Business logic
│   │   └── pdf/                        # PDF generation
│   ├── leaflet/                        # Symbology, utilities
│   ├── map/                            # Map utilities
│   └── types.d.ts                      # Shared types
└── stores/                             # Svelte stores (migrating to runes)
```

---

## Quick Troubleshooting

**Map not displaying:**
- Verify Leaflet CSS imported in `+layout.svelte`
- Check map container has explicit height (not `height: auto`)
- Ensure dynamic import in `onMount`, not top-level
- Call `map.invalidateSize()` after container resize

**Spatial data not loading:**
- Verify PostGIS extension enabled in Supabase
- Check SRID is 7844 for all geometries
- Validate GeoJSON structure with `ST_IsValid`
- Confirm RLS policies allow access

**Authentication issues:**
- Check JWT not expired (Supabase dashboard)
- Verify custom claims in JWT (decode at jwt.io)
- Test query directly in Supabase SQL editor with RLS enabled
- Confirm user has required property_ids in claims

**Vector tiles not loading:**
- Verify Geoscape API key valid and not rate-limited
- Check tile coordinates (z/x/y) are within bounds
- Ensure PBF decoding library imported
- Check browser console for CORS errors

---

**Last Updated:** 2025-01-24
**Maintained by:** Alan (GIS developer)
**SvelteKit:** 2.x | **Svelte:** 5.x | **Supabase:** Latest | **Leaflet:** 1.9.x