import PdfPrinter from 'pdfmake';
import blobStream from 'blob-stream';
import { fonts, getLogo } from '$lib/server/pdf/config/pdfConfig';

import type { RfsReportData } from '$lib/server/pdf/types/rfs';
import type { TDocumentDefinitions, Content, Alignment, StyleDictionary } from 'pdfmake/interfaces';

interface RfsStreetReportParams {
	streetName: string;
	propertyData: RfsReportData[];
	generatedBy: string;
}

export async function generateRfsStreetReport({
	streetName,
	propertyData,
	generatedBy
}: RfsStreetReportParams): Promise<Blob> {
	const printer = new PdfPrinter(fonts);
	const content = buildReportContent(streetName, propertyData);
	const styles = getReportStyles();

	const documentDefinition: TDocumentDefinitions = {
		footer: (currentPage: number, pageCount: number) => ({
			columns: [
				{
					text: 'Strengthen Our Community',
					style: 'footer',
					width: '30%'
				},
				{
					text: `Generated by: ${generatedBy} | Page ${currentPage} of ${pageCount}`,
					style: 'footer',
					width: '40%',
					alignment: 'center'
				},
				{
					text: new Date().toLocaleString(),
					style: 'footer',
					width: '30%',
					alignment: 'right'
				}
			],
			margin: [40, 0, 40, 0],
			display: currentPage === 1 ? 'none' : 'block'
		}),
		content,
		styles,
		defaultStyle: {
			font: 'Poppins'
		}
	};

	return new Promise((resolve, reject) => {
		try {
			const pdfDoc = printer.createPdfKitDocument(documentDefinition);
			const stream = pdfDoc.pipe(blobStream());

			stream.on('finish', function (this: any) {
				console.log('Stream finished');
				resolve(this.toBlob('application/pdf'));
			});

			stream.on('error', (error) => {
				console.error('Stream error:', error.stack || error);
				reject(error);
			});

			pdfDoc.on('error', (error) => {
				console.error('PDF document error:', error.stack || error);
				reject(error);
			});

			pdfDoc.end();
		} catch (error) {
			console.error('Error in PDF creation:', error instanceof Error ? error.stack : error);
			reject(error);
		}
	});
}

function getReportStyles(): StyleDictionary {
	return {
		title_h1: {
			font: 'Poppins',
			fontSize: 26,
			bold: true,
			alignment: 'center',
			color: '#1e293b'
		},
		title_h2: {
			font: 'Inter',
			fontSize: 22,
			margin: [0, 20, 0, 20],
			alignment: 'center',
			color: '#334155'
		},
		sectionHeader: {
			font: 'OpenSans',
			fontSize: 14,
			bold: true,
			fillColor: '#c2410c',
			color: 'white',
			margin: [0, 10, 0, 5]
		},
		tableContent: {
			font: 'Inter',
			fontSize: 11,
			color: '#1e293b'
		},
		propertyAddress: {
			font: 'Poppins',
			fontSize: 16,
			bold: true,
			color: '#1e293b',
			alignment: 'center',
			margin: [0, 10, 0, 10]
		},
		footer: {
			font: 'Inter',
			fontSize: 9,
			color: '#64748b',
			margin: [40, 0]
		},
		quickRefHeader: {
			font: 'Poppins',
			fontSize: 12,
			bold: true,
			color: '#0f172a',
			margin: [0, 0, 0, 5] as [number, number, number, number]
		},
		criticalFlag: {
			font: 'Inter',
			fontSize: 12,
			bold: true,
			color: '#991b1b',
			lineHeight: 1.5
		},
		warningHeader: {
			font: 'Poppins',
			fontSize: 14,
			bold: true,
			alignment: 'center',
			margin: [0, 5, 0, 5]
		},
		emergencyHeader: {
			font: 'Poppins',
			fontSize: 14,
			bold: true,
			alignment: 'center',
			margin: [0, 5, 0, 5]
		},
		hazardLabel: {
			font: 'Inter',
			fontSize: 11,
			bold: true,
			color: '#1e293b'
		},
		contactLabel: {
			font: 'Inter',
			fontSize: 10,
			bold: true,
			color: '#0369a1'
		},
		warningText: {
			font: 'Inter',
			color: '#dc2626',
			bold: true
		},
		emergencyText: {
			font: 'Inter',
			color: '#0369a1',
			bold: true
		}
	};
}

function buildReportContent(streetName: string, propertyData: RfsReportData[]): Content[] {
	const content: Content[] = [];

	// Cover page
	content.push(
		{
			image: getLogo(),
			width: 200,
			alignment: 'center' as Alignment,
			margin: [0, 100, 0, 30]
		},
		{
			text: 'RFS Emergency Report',
			style: 'title_h1',
			alignment: 'center'
		},
		{
			text: 'for',
			style: 'title_h2',
			alignment: 'center'
		},
		{
			text: streetName,
			style: 'title_h1',
			alignment: 'center',
			margin: [0, 0, 0, 30]
		},
		{ text: '', pageBreak: 'after' }
	);

	// Property sections
	propertyData.forEach((property, index) => {
		content.push(
			buildPropertyHeader(property),
			buildCriticalFlags(property),
			buildQuickReferenceSummary(property),
			buildEmergencyContactsSection(property),
			buildHazardsTable(property),
			buildLocalHazardsTable(property),
			buildFireAssetsTable(property),
			buildAnimalsTable(property),
			buildResidentsTable(property),
			index < propertyData.length - 1 ? { text: '', pageBreak: 'after' } : { text: '' }
		);
	});

	return content;
}

function buildPropertyHeader(property: RfsReportData): Content {
	const ageProfile = `Ages 0-18: ${property.property.age_profile.age0_18} | Ages 19-50: ${property.property.age_profile.age19_50} | Ages 51-70: ${property.property.age_profile.age51_70} | Ages 71+: ${property.property.age_profile.age71_}`;

	const headerContent: Content = {
		stack: [
			{
				table: {
					widths: ['*'],
					body: [
						[{ text: property.address, style: 'tableHeader', alignment: 'center' }],
						[{ text: `Landline: ${property.phone}`, alignment: 'center' }],
						[{ text: `Age Profile: ${ageProfile}`, alignment: 'center' }]
					]
				},
				layout: 'noBorders'
			}
		]
	};

	if (property.agentinformation) {
		(headerContent.stack as Content[]).push({
			table: {
				widths: ['auto', '*'] as string[],
				body: [
					['Agent Name:', property.agentinformation.agentname],
					['Agent Mobile:', property.agentinformation.agentmobile],
					['Agent Phone:', property.agentinformation.agentphone]
				]
			},
			layout: 'lightHorizontalLines'
		});
	}

	return headerContent;
}

function buildHazardsTable(property: RfsReportData) {
	return {
		stack: [
			{
				table: {
					headerRows: 1,
					widths: ['*'],
					body: [
						[
							{
								text: [
									{ text: '⚠️', font: 'NotoEmoji' },
									{ text: ' HAZARDS', font: 'Poppins' }
								],
								style: 'warningHeader',
								fillColor: '#dc2626',
								color: 'white'
							}
						]
					]
				}
			},
			{
				table: {
					widths: ['30%', '*'],
					body: [
						...Object.entries(property.onsite_hazards.on_site_hazards).map(([key, value]) => [
							{ text: key.replace(/_/g, ' '), style: 'hazardLabel' },
							{
								text: value,
								fillColor: value.toLowerCase() === 'yes' ? '#fee2e2' : '#ffffff'
							}
						]),
						[
							{ text: 'Other Hazards:', style: 'hazardLabel' },
							{
								text: property.onsite_hazards.other_site_hazards,
								fillColor: property.onsite_hazards.other_site_hazards ? '#fee2e2' : '#ffffff'
							}
						]
					]
				},
				layout: {
					fillColor: (rowIndex: number) => (rowIndex % 2 === 0 ? '#fafafa' : null),
					hLineWidth: () => 0.5,
					vLineWidth: () => 0.5
				}
			}
		]
	};
}

function buildEmergencyContactsSection(property: RfsReportData): Content {
	const emergencyContacts = property.residents
		.filter((resident) => resident.resident === 'Primary')
		.map((contact) => ({
			name: contact.name,
			mobile: contact.mobile
		}));

	return {
		stack: [
			{
				table: {
					widths: ['*'] as string[],
					body: [
						[
							{
								text: [
									{ text: '🚨', font: 'NotoEmoji' },
									{ text: ' EMERGENCY CONTACTS', font: 'Poppins' }
								],
								style: 'emergencyHeader',
								fillColor: '#0369a1',
								color: 'white'
							}
						]
					]
				}
			},
			{
				table: {
					widths: ['33%', '33%', '34%'] as string[],
					body: [
						[
							{ text: 'PRIMARY CONTACT', style: 'contactLabel' },
							{ text: 'MOBILE', style: 'contactLabel' },
							{ text: 'LANDLINE', style: 'contactLabel' }
						],
						...emergencyContacts.map((contact) => [
							{ text: contact.name, bold: true },
							{ text: contact.mobile },
							{ text: property.phone || 'N/A' }
						])
					]
				},
				layout: {
					fillColor: (rowIndex: number) => (rowIndex === 0 ? '#e0f2fe' : null),
					hLineWidth: () => 0.5,
					vLineWidth: () => 0.5
				}
			}
		],
		margin: [0, 0, 0, 20] as [number, number, number, number]
	};
}

function buildFireAssetsTable(property: RfsReportData) {
	return {
		stack: [
			{
				table: {
					widths: ['*'],
					body: [
						[
							{
								text: [
									{ text: '🚒', font: 'NotoEmoji' },
									{ text: ' FIRE FIGHTING ASSETS', font: 'Poppins', bold: true }
								],
								fillColor: '#c2410c',
								color: 'white',
								margin: [5, 2, 5, 2]
							}
						]
					]
				},
				layout: 'noBorders'
			},
			{
				table: {
					widths: ['auto', '*'],
					body: [
						['Static Water:', property.fire_fighting_assets.static_water],
						['Stortz Fitting:', property.fire_fighting_assets.stortz_fitting],
						['Equipment:', property.fire_fighting_assets.equipment],
						['Firebreaks:', property.fire_fighting_assets.firebreaks],
						['Slashed APZ(s):', property.fire_fighting_assets.slashed_apz_s],
						['Backup Pump:', property.fire_fighting_assets.backup_pump],
						['Driveway Clearance:', property.fire_fighting_assets.driveway_overhead_clearance],
						['Truck Access:', property.fire_fighting_assets.truck_access_around_property]
					]
				},
				layout: 'lightHorizontalLines'
			}
		]
	};
}

function buildResidentsTable(property: RfsReportData): Content {
	return {
		stack: [
			{
				table: {
					widths: ['*'],
					body: [
						[
							{
								text: [
									{ text: '👥', font: 'NotoEmoji' },
									{ text: ' RESIDENTS', font: 'Poppins', bold: true }
								],
								fillColor: '#c2410c',
								color: 'white',
								margin: [5, 2, 5, 2]
							}
						]
					]
				},
				layout: 'noBorders'
			},
			...property.residents.map((resident) => ({
				table: {
					widths: ['auto', '*'],
					body: [
						['Name:', resident.name],
						['Mobile:', resident.mobile],
						['Occupancy:', resident.resident],
						['Survival Plan:', resident.survival_plan],
						['Plan to Leave:', resident.plan_to_leave]
					]
				},
				layout: 'lightHorizontalLines',
				margin: [0, 0, 0, 10] as [number, number, number, number]
			}))
		]
	};
}

function buildLocalHazardsTable(property: RfsReportData) {
	return {
		stack: [
			{
				table: {
					widths: ['*'],
					body: [
						[
							{
								text: [
									{ text: '🌳', font: 'NotoEmoji' },
									{ text: ' LOCAL HAZARDS', font: 'Poppins', bold: true }
								],
								fillColor: '#c2410c',
								color: 'white',
								margin: [5, 2, 5, 2]
							}
						]
					]
				},
				layout: 'noBorders'
			},
			{
				table: {
					widths: ['auto', '*'],
					body: [
						['Adjacent Land Hazards:', property.other_local_hazards.land_adjacent_hazard],
						['Other Local Hazards:', property.other_local_hazards.other_local_hazards]
					]
				},
				layout: 'lightHorizontalLines'
			}
		]
	};
}

function buildAnimalsTable(property: RfsReportData) {
	const safeAreaText = property.site_animals.safe_area
		? property.site_animals.safe_area.status
		: 'Not specified';

	return {
		stack: [
			{
				table: {
					widths: ['*'],
					body: [
						[
							{
								text: [
									{ text: '🐾', font: 'NotoEmoji' },
									{ text: ' ANIMALS', font: 'Poppins', bold: true }
								],
								fillColor: '#c2410c',
								color: 'white',
								margin: [5, 2, 5, 2]
							}
						]
					]
				},
				layout: 'noBorders'
			},
			{
				table: {
					widths: ['auto', '*'],
					body: [
						[
							'Pets:',
							`Dogs: ${property.site_animals.pets.dogs} | Cats: ${property.site_animals.pets.cats} | Birds: ${property.site_animals.pets.birds}`
						],
						['Other Pets:', property.site_animals.pets.other_pets],
						['Livestock:', property.site_animals.livestock],
						['Safe Area:', safeAreaText]
					]
				},
				layout: 'lightHorizontalLines'
			}
		]
	};
}

function buildCriticalFlags(property: RfsReportData): Content {
	const criticalItems = [];

	if (property.property.vulnerable === 'Yes') {
		criticalItems.push([
			{ text: '⚠️', font: 'NotoEmoji' },
			{ text: ' Vulnerable Residents', font: 'Poppins' }
		]);
	}

	if (property.onsite_hazards.on_site_hazards.Fuel_stores === 'Yes') {
		criticalItems.push([
			{ text: '⚠️', font: 'NotoEmoji' },
			{ text: ' Fuel Storage Present', font: 'Poppins' }
		]);
	}

	if (property.fire_fighting_assets.truck_access_around_property === 'Limited') {
		criticalItems.push([
			{ text: '⚠️', font: 'NotoEmoji' },
			{ text: ' Limited Truck Access', font: 'Poppins' }
		]);
	}

	return criticalItems.length
		? {
				table: {
					widths: ['*'],
					body: [
						[
							{
								text: criticalItems.reduce((acc, item, index) => {
									if (index === 0) return item;
									return [...acc, { text: ' | ', font: 'Poppins' }, ...item];
								}, []),
								style: 'criticalFlag',
								alignment: 'center'
							}
						]
					]
				},
				layout: {
					fillColor: '#fef2f2',
					hLineWidth: () => 0
				},
				margin: [0, 0, 0, 10]
			}
		: { text: '' };
}

function buildQuickReferenceSummary(property: RfsReportData): Content {
	return {
		table: {
			widths: ['*', '*', '*'] as string[],
			body: [
				[
					{
						stack: [
							{
								text: [
									{ text: '🚒', font: 'NotoEmoji' },
									{ text: ' FIRE ASSETS', font: 'Poppins' }
								],
								style: 'quickRefHeader'
							},
							{ text: `Static Water: ${property.fire_fighting_assets.static_water}` },
							{ text: `Equipment: ${property.fire_fighting_assets.equipment}` }
						]
					},
					{
						stack: [
							{
								text: [
									{ text: '👥', font: 'NotoEmoji' },
									{ text: ' OCCUPANTS', font: 'Poppins' }
								],
								style: 'quickRefHeader'
							},
							{ text: `Total: ${property.residents.length}` },
							{ text: `Vulnerable: ${property.property.vulnerable}` }
						]
					},
					{
						stack: [
							{
								text: [
									{ text: '🚗', font: 'NotoEmoji' },
									{ text: ' ACCESS', font: 'Poppins' }
								],
								style: 'quickRefHeader'
							},
							{ text: `Truck Access: ${property.property.truck_access}` },
							{ text: `Clearance: ${property.fire_fighting_assets.driveway_overhead_clearance}` }
						]
					}
				]
			]
		},
		layout: 'headerLineOnly',
		margin: [0, 0, 0, 20] as [number, number, number, number]
	};
}
